http://postgis.refractions.net/documentation/manual-1.3/ch03.html
./osmosis -v 100 --read-xml file=../../../planetosm/planet-100407.osm --write-pgsql host=localhost:5433 user=postgres database=lgd password=
java -jar LineStringUpdater.jar -dlgd_simple_0_6_postgis_1_3 -n1000 -upostgres -p[] 


select id, linestring into way_lines from ways where linestring IS NOT NULL;
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;

Relation DatabaseState
-------------------------------------------------------------------------------
Used for keeping track of the state of certain processes - e.g. the date of the
most recently loaded dataset (as opposed to the date of load process)

CREATE TABLE DatabaseState (
	key TEXT NOT NULL PRIMARY KEY,
	value TEXT
);

INSERT INTO DatabaseState(key, value) VALUES('dataset', '2010-04-07 00:00:00');



Geography test
-------------------------------------------------------------------------------
/* Conversion of nodes table: */
SELECT id, version, user_id, tstamp, changeset_id, geom::geography INTO geognodes FROM nodes;
ALTER TABLE nodes RENAME TO nodes_orig;
ALTER INDEX idx_nodes_geom RENAME TO idx_nodes_orig_geom;
ALTER TABLE geognodes RENAME to nodes;
ALTER TABLE nodes ADD PRIMARY KEY(id);
CREATE INDEX idx_nodes_geom ON nodes USING GIST(geom);

/* Same for ways: */
SELECT id, version, user_id, tstamp, changeset_id, linestring::geography INTO geogways FROM ways;
ALTER TABLE ways RENAME TO ways_orig;
ALTER INDEX idx_ways_linestring RENAME TO idx_ways_orig_linestring;
ALTER TABLE geogways RENAME to ways;
ALTER TABLE ways ADD PRIMARY KEY(id);
CREATE INDEX idx_ways_linestring ON ways USING GIST(linestring);




create index idx_geogtest_geog on geogtest using gist(geog);
explain select id from geogtest where ST_DWithing(


Performance tests of real queries
-------------------------------------------------------------------------------
Slow counts are a known problem/feature of postgres, (mysql often uses cached counts)
here is some reading:
http://blog.charcoalphile.com/2007/12/12/postgresql-count-workaround/
http://www.varlena.com/GeneralBits/49.php



SELECT r.id FROM resources r WHERE r.label = 'amenity';
SELECT t.v, COUNT(*) AS c FROM lgd_tags t WHERE k=1590 GROUP BY t.v HAVING COUNT(t.v) > 10;

SELECT COUNT(*) FROM lgd_tags t WHERE k=1590 GROUP BY t.v;





Distance(), ST_Intersects(), ST_Contains() and ST_Within(),
WHERE the_geom && 'BOX3D(90900 190900, 100100 200100)'::box3d

create index idx_test on nodes using gist(geom) WHERE user_id > 1000 and user_id < 2000;
explain select * from nodes where Distance(geom, 'POINT(0.0 0.0)', 1000) and user_id > 4;


This query doesn't use indices:
Ok, the reference clearifies: http://postgis.refractions.net/documentation/manual-1.3/ch06.html
Its just the cartesian distance between two vectors - so nothing geo specific.
SELECT * FROM view_geoms g WHERE Distance(g.geom, GeomFromEWKT('SRID=4326;POINT(13.828.0 50.99)')) < 1000;


This query seems to work efficiently:
SELECT * FROM view_geoms g WHERE ST_DWithin(g.geom, GeomFromEWKT('SRID=4326;POINT(13.828 50.99)'), 10);


Additional Indices for the OSM schema:
-------------------------------------------------------------------------------
CREATE INDEX idx_node_tags_k_v ON node_tags(k, v);
CREATE INDEX idx_way_tags_k_v ON way_tags(k, v);
CREATE INDEX idx_relation_tags_k_v ON relation_tags(k, v);



Tokyo: http://linkedgeodata.org:7000/triplify/near/35.41,139.42/1000
Leipzig: http://linkedgeodata.org:7000/triplify/near/51.20,12.22/1000/amenity



Exception: http://localhost:7000/triplify/way/33241659 (not tried locally yet)
-------------------------------------------------------------------------------



Resource table
-------------------------------------------------------------------------------
DROP TABLE IF EXISTS lgd_resources;
CREATE TABLE resources (
	id    BIGSERIAL,
	label TEXT NOT NULL UNIQUE
);



INSERT
	INTO resources(label)
SELECT 
	DISTINCT t.k
FROM
	way_tags t
WHERE
	NOT EXISTS(SELECT r.id FROM resources r WHERE r.label = t.k)


INSERT
	INTO resources(label)
SELECT 
	DISTINCT tmp.label
FROM
	((SELECT tk.k AS label FROM tags AS tk)
	UNION ALL (SELECT tv.v AS label FROM tags AS tv)) tmp
WHERE
	NOT EXISTS(SELECT r.id FROM resources r WHERE r.label = tmp.label)
;


INSERT
	INTO resources(label)
SELECT 
	DISTINCT tmp.label
FROM
	((SELECT DISTINCT tk.k AS label FROM relation_tags AS tk)
	UNION ALL (SELECT DISTINCT tv.v AS label FROM relation_tags AS tv)) tmp
WHERE
	NOT EXISTS(SELECT r.id FROM resources r WHERE r.label = tmp.label)
;



INSERT
	INTO resources(label)
		SELECT
			t.k
		FROM
			node_tags t
		WHERE
			NOT EXISTS(SELECT r.id FROM resources r WHERE r.label = t.k)
;


LGD-Tags
-------------------------------------------------------------------------------
DROP TABLE IF EXISTS lgd_tags;
CREATE TABLE lgd_tags (
	osm_entity_type OSMEntityType,
	id    BIGINT,
	k     BIGINT,
	v     BIGINT
);

CREATE INDEX idx_lgd_tags_osm_entity_type_id ON lgd_tags(osm_entity_type, id);
CREATE INDEX idx_lgd_tags_k_v ON lgd_tags(k, v);



INSERT
	INTO lgd_tags(osm_entity_type, id, k, v)
SELECT
	OSMEntityType('way'), t.way_id, rk.id, rv.id
FROM
	way_tags t
	INNER JOIN resources rk ON (rk.label = t.k)
	INNER JOIN resources rv ON (rv.label = t.v)
;



Tile statistics (key only)
-------------------------------------------------------------------------------
DROP TABLE IF EXISTS lgd_stats_tile_key_count;
CREATE TABLE lgd_stats_tile_key_count (
	tile BIGINT(10)   NOT NULL,
	k    BIGINT       NOT NULL,
	c    UNSIGNED INT NOT NULL,
	
	PRIMARY KEY(tile, key)
);


Tile statistics (key-value)
-------------------------------------------------------------------------------
DROP TABLE IF EXISTS lgd_stats_tile_key_value_freq;
CREATE TABLE lgd_stats_tile_key_value_freq (
	tile  BIGINT(10)   NOT NULL,
	k     BIGINT       NOT NULL,
	v     BIGINT       NOT NULL,
	c    UNSIGNED INT NOT NULL,
	
	PRIMARY KEY(tile, key)
);



View for ways and nodes
-------------------------------------------------------------------------------
CREATE VIEW view_geoms AS
	SELECT
		t.type, t.id, t.geom
	FROM
		((SELECT OSMEntityType('node') AS type, n.id AS id, n.geom FROM nodes n) UNION ALL
		 (SELECT OSMEntityType('way') AS type, w.id AS id, w.linestring AS geom FROM ways w)) AS t;


-------------------------------------------------------------------------------


trigger
Enabling/Disabling of triggers:
DISABLE TRIGGER [ trigger_name | ALL | USER ]
ENABLE TRIGGER [ trigger_name | ALL | USER ]


OSMEntityType
-------------------------------------------------------------------------------os
DROP TYPE IF EXISTS OSMEntityType;
CREATE TYPE OSMEntityType AS ENUM ('node', 'way', 'relation');
-------------------------------------------------------------------------------


OntologyEntityType
-------------------------------------------------------------------------------
DROP TYPE IF EXISTS OntologyEntityType;
CREATE TYPE OntologyEntityType AS ENUM ('Class', 'ObjectProperty', 'DatatypeProperty');
-------------------------------------------------------------------------------



elements table definition
-------------------------------------------------------------------------------



-------------------------------------------------------------------------------


elements table initialization

('created_by','ele','time','layer','source','tiger:tlid','tiger:county','tiger:upload_uuid','attribution','source_ref','KSJ2:coordinate','KSJ2:lat','KSJ2:long','KSJ2:curve_id','AND_nodes','converted_by');


properties table creation
-------------------------------------------------------------------------------
CREATE TABLE properties(
	k                    TEXT               NOT NULL,
	ontology_entity_type OntologyEntityType,
	usage_count          BIGINT             NOT NULL,
	distinct_value_count BIGINT             NOT NULL,
	PRIMARY KEY(k)
);

CREATE INDEX idx_properties_ontology_entity_type_k ON properties(ontology_entity_type, k);


property table initialization
-------------------------------------------------------------------------------
INSERT INTO
	properties(k, ontology_entity_type, usage_count, distinct_value_count)
SELECT
	t.k, NULL, COUNT(t.k), COUNT(DISTINCT t.v)
FROM 
	tags AS t
GROUP BY
	t.k


Classification query (for properties)
-------------------------------------------------------------------------------
UPDATE
	properties p
SET ontology_entity_type = 'Class'
WHERE p.k IN (
	'highway','barrier','cycleway','waterway','lock','railway','aeroway','aerialway','power','man_made','building','leisure','amenity','shop','tourism','historic','landuse','military','natural','route','boundary','sport'
);




-------------------------------------------------------------------------------

 id           | bigint                      | not null
 version      | integer                     | not null





view_tags [FINAL]
Note: Using strings instead of enums or integers doesn't work with the optimizer
-------------------------------------------------------------------------------
CREATE VIEW tags AS
	SELECT
		t.osm_entity_type, t.osm_entity_id, t.k, t.v
	FROM
		((SELECT OSMEntityType('node') AS osm_entity_type, node_id AS osm_entity_id, k, v FROM node_tags) UNION ALL
		 (SELECT OSMEntityType('way') AS osm_entity_type, way_id AS osm_entity_id, k, v FROM way_tags) UNION ALL
		 (SELECT OSMEntityType('relation') AS osm_entity_type, relation_id AS osm_entity_id, k, v FROM relation_tags)) AS t;
-------------------------------------------------------------------------------











CREATE VIEW view_tags AS SELECT
type, id, k, v
FROM
((SELECT 1 AS type, node_id AS id, k, v FROM node_tags) UNION ALL
(SELECT 2 AS type, way_id AS id, k, v FROM way_tags) UNION ALL
(SELECT 3 AS type, relation_id AS id, k, v FROM relation_tags)) AS tags;






CREATE VIEW view_tags AS SELECT
*
FROM
((SELECT 'node' AS type, node_id AS id, k, v FROM node_tags) UNION ALL
(SELECT 'way' AS type, way_id AS id, k, v FROM way_tags) UNION ALL
(SELECT 'relation' AS type, relation_id AS id, k, v FROM relation_tags)) AS tags;

CREATE VIEW view_tags AS SELECT
type, id, k, v
FROM
((SELECT 'node' AS type, id, k, v FROM (SELECT node_id AS id, k, v FROM node_tags) AS a) UNION ALL
(SELECT 'way'  AS type, id, k, v FROM (SELECT way_id  AS id, k, v FROM way_tags) AS b) UNION ALL
(SELECT 'relation' AS type, id, k, v FROM (SELECT relation_id AS id, k, v FROM relation_tags) AS c)) AS tags;




SELECT
	COUNT(*)
FROM
	((SELECT 'node' AS type, node_id AS id, k, v FROM node_tags) UNION ALL
	(SELECT 'way' AS type, way_id AS id, k, v FROM way_tags) UNION ALL
	(SELECT 'relation' AS type, relation_id AS id, k, v FROM relation_tags)) AS tags
;



		SELECT
			mm.way_id,
			CASE WHEN wn_min.node_id = wn_max.node_id THEN
				CASE WHEN mm.node_count >= 4 THEN 'polygon' ELSE 'error' END
			ELSE
				CASE WHEN mm.node_count >= 2 THEN 'line' ELSE 'error' END
			END
			AS way_type
		FROM (
			SELECT
				wn.way_id,
				MIN(wn.sequence_id) AS min_seq_id,
				MAX(wn.sequence_id) AS max_seq_id,
				COUNT(*) AS node_count
			FROM
				way_nodes wn
			WHERE
				wn.way_id = 92
			GROUP BY
				wn.way_id
		) mm
			INNER JOIN way_nodes wn_min ON ((wn_min.way_id, wn_min.sequence_id) = (mm.way_id, mm.min_seq_id))
			INNER JOIN way_nodes wn_max ON ((wn_max.way_id, wn_max.sequence_id) = (mm.way_id, mm.max_seq_id))
		;





Get the pure coordinates (maybe not the most elegant version though) - used for georrs
select REPLACE(REPLACE(REPLACE(ST_AsText(ST_Affine(linestring, 0, 1, 1, 0, 0, 0)), 'LINESTRING(', ''), ',', ' '), ')', '') from ways where id = 4279538;
ST_Affine(linestring, 0, 1, 1, 0, 0, 0)


GROUP_CONCAT QUERY:
	SELECT
	    w.id,
		array_to_string(array(
			SELECT
				X(n.geom) || ' ' || Y(n.geom)
			FROM
				way_nodes wn
				INNER JOIN nodes n ON (n.id = wn.node_id)
			WHERE
				wn.way_id = w.id
			ORDER BY
				wn.sequence_id
		), ' ') AS val
	FROM
		ways w
	WHERE
		w.id = 92


			SELECT
				wn.way_id, wn.sequence_id, n.id, X(n.geom) || ' ' || Y(n.geom)
			FROM
				way_nodes wn
				INNER JOIN nodes n ON (n.id = wn.node_id)
			WHERE
				wn.way_id = 92
			ORDER BY
				wn.sequence_id






Unfortunately the view is not browsable this way
(e.g. select * from waylines LIMIT 5 does not work)
DROP VIEW IF EXISTS waylines;
CREATE VIEW
	waylines
AS
SELECT
	c.way_id,
	MakeLine(c.geom) AS way_line
FROM
	(
		SELECT
			wn.way_id,
			n.geom
		FROM
			way_nodes wn
			INNER JOIN nodes n ON (n.id = wn.node_id)
		ORDER BY
			wn.way_id,
			wn.sequence_id
	) AS c
GROUP BY
	c.way_id
;


DROP FUNCTION LGD_test(val INT8);
CREATE FUNCTION LGD_test(val INT8) RETURNS INT8 AS
'
DECLARE
	result INT4 := 0;
BEGIN

    FOR i IN 0..val LOOP
        result := i;
    END LOOP;
    RETURN result;
END;
'
    LANGUAGE 'plpgsql'
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;


What i want now is a function that assigns a point to its tile.

Test data:
lat=50.1359444
lon=8.3013034
expected tile: 3493312635


DROP FUNCTION LGD_WidenBits(INT4, INT4);
CREATE FUNCTION LGD_WidenBits(val INT4, n INT4) RETURNS INT8 AS
'
DECLARE
	tmp INT8;
	result INT8 := 0;
BEGIN

    FOR i IN 0..n LOOP
        tmp := (val >> i) & 1;
        tmp := tmp << (i * 2);
        result := result | tmp;
    END LOOP;
    RETURN result;
END;
'
    LANGUAGE 'plpgsql'
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;


DROP FUNCTION LGD_ShrinkBits(INT8, INT4);
CREATE FUNCTION LGD_ShrinkBits(val INT8, n INT4) RETURNS INT4 AS
'
DECLARE
	tmp INT4;
	result INT4 := 0;
BEGIN

    FOR i IN 0..n LOOP
        tmp := (val >> (i * 2)) & 1;
        tmp := tmp << i;
        result := result | tmp;
    END LOOP;
    RETURN result;
END;
'
    LANGUAGE 'plpgsql'
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;




DROP FUNCTION LGD_BitZip(INT4, INT4);
CREATE FUNCTION LGD_BitZip(lat INT4, lon INT4) RETURNS INT8 AS
'
DECLARE
	tmpLat INT4;
	tmpLon INT4;
BEGIN
    IF lat > 65535 THEN tmpLat := 65535; ELSE tmpLat := lat; END IF;
    IF lon > 65535 THEN tmpLon := 65535; ELSE tmpLon := lon; END IF;
    
    RETURN (LGD_WidenBits(tmpLon, 15) << 1) | LGD_WidenBits(tmpLat, 15); 
END;
'
    LANGUAGE 'plpgsql'
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;


DROP FUNCTION LGD_ToTile(Geometry);
CREATE FUNCTION LGD_ToTile(geom Geometry) RETURNS INT8 AS
'
DECLARE
	lat INT4;
	lon INT4;
BEGIN
    lat := TRUNC((Y(geom) + 90.0) / 180.0 * 65536.0)::INT4;
	lon := TRUNC((X(geom) + 180.0) / 360.0 * 65536.0)::INT4;
    
    RETURN LGD_BitZip(lat, lon); 
END;
'
    LANGUAGE 'plpgsql'
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;





DROP FUNCTION LGD_ToBBox(tile INT8);
CREATE FUNCTION LGD_ToBBox(tile INT8) RETURNS Geometry AS
'
DECLARE
    lat    INT4;
    lon    INT4;
	latMin FLOAT;
	latMax FLOAT;
	lonMin FLOAT;
	lonMax FLOAT;
BEGIN
    lat := LGD_ShrinkBits(tile, 15);
    lon := LGD_ShrinkBits(tile >> 1, 15);
    
    latMin := lat / 65536.0 * 180.0 - 90.0;
	latMax := (lat + 1) / 65536.0 * 180.0 - 90.0;

	lonMin := lon / 65536.0 * 360.0 - 180.0;
	lonMax := (lon + 1) / 65536.0 * 360.0 - 180.0;


    RETURN ST_SetSRID(ST_MakeBox2D(ST_MakePoint(lonMin, latMin), ST_MakePoint(lonMax, latMax)), 4326); 
END;
'
    LANGUAGE 'plpgsql'
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;






/* Black list table: Tags with those keys should be ignored for various tasks */
CREATE TABLE BlackListK (
	k TEXT PRIMARY KEY
)
	IF latMin < -180 THEN latMin = -180 END IF;
	IF lonMin < -180 THEN latMin = -180 END IF;
	IF latMin < -180 THEN latMin = -180 END IF;
	IF latMin < -180 THEN latMin = -180 END IF;
*/



BlackListKV

// Step 1: Find all tiles that are there
// Step 2: For each tile create the bounding box


// for a tile, how often the value k appears in tags
CREATE TABLE TilesK16 (
	tile_id INTEGER PRIMARY KEY,
	k TEXT NOT NULL,
	c INTEGER count
)

So the next step is: For each tile we need to aggregate the keys that are in there.
INSERT
	INTO TilesK16
SELECT
	



Some test
------
DROP FUNCTION LGD_ToT(Geometry);
CREATE FUNCTION LGD_ToT(geom Geometry) RETURNS Geometry AS
'
DECLARE
	lat INT4;
	lon INT4;
BEGIN
    lat := TRUNC((Y(geom) + 90.0) / 180.0 * 65536.0)::int4;
	lon := TRUNC((X(geom) + 180.0) / 360.0 * 65536.0)::int4; 
    
    RETURN MakePoint(lat, lon);
END;
'
    LANGUAGE 'plpgsql'
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;





